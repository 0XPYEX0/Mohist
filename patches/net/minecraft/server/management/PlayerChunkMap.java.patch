--- ../src-base/minecraft/net/minecraft/server/management/PlayerChunkMap.java
+++ ../src-work/minecraft/net/minecraft/server/management/PlayerChunkMap.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.management;
 
+import co.aikar.timings.Timing;
 import com.google.common.base.Predicate;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ComparisonChain;
@@ -7,12 +8,15 @@
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.Nullable;
+import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
@@ -20,6 +24,7 @@
 import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraftforge.common.util.ChunkCoordComparator;
 
 public class PlayerChunkMap
 {
@@ -52,7 +57,7 @@
     public PlayerChunkMap(WorldServer serverWorld)
     {
         this.world = serverWorld;
-        this.setPlayerViewRadius(serverWorld.getMinecraftServer().getPlayerList().getViewDistance());
+        this.setPlayerViewRadius(serverWorld.spigotConfig.viewDistance); // Spigot
     }
 
     public WorldServer getWorldServer()
@@ -109,6 +114,7 @@
 
         if (i - this.previousTotalWorldTime > 8000L)
         {
+            try (Timing ignored = world.timings.doChunkMapUpdate.startTiming()) { // Paper
             this.previousTotalWorldTime = i;
 
             for (int j = 0; j < this.entries.size(); ++j)
@@ -117,21 +123,25 @@
                 playerchunkmapentry.update();
                 playerchunkmapentry.updateChunkInhabitedTime();
             }
+            } // Paper timing
         }
 
         if (!this.dirtyEntries.isEmpty())
         {
+            try (Timing ignored = world.timings.doChunkMapToUpdate.startTiming()) { // Paper
             for (PlayerChunkMapEntry playerchunkmapentry2 : this.dirtyEntries)
             {
                 playerchunkmapentry2.update();
             }
 
             this.dirtyEntries.clear();
+            } // Paper timing
         }
 
         if (this.sortMissingChunks && i % 4L == 0L)
         {
             this.sortMissingChunks = false;
+            try (Timing ignored = world.timings.doChunkMapSortMissing.startTiming()) { // Paper
             Collections.sort(this.entriesWithoutChunks, new Comparator<PlayerChunkMapEntry>()
             {
                 public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_)
@@ -139,11 +149,13 @@
                     return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
                 }
             });
+            } // Paper timing
         }
 
         if (this.sortSendToPlayers && i % 4L == 2L)
         {
             this.sortSendToPlayers = false;
+            try (Timing ignored = world.timings.doChunkMapSortSendToPlayers.startTiming()) { // Paper
             Collections.sort(this.pendingSendToPlayers, new Comparator<PlayerChunkMapEntry>()
             {
                 public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_)
@@ -151,10 +163,12 @@
                     return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
                 }
             });
+            } // Paper timing
         }
 
         if (!this.entriesWithoutChunks.isEmpty())
         {
+            try (Timing ignored = world.timings.doChunkMapPlayersNeedingChunks.startTiming()) { // Paper
             long l = System.nanoTime() + 50000000L;
             int k = 49;
             Iterator<PlayerChunkMapEntry> iterator = this.entriesWithoutChunks.iterator();
@@ -183,13 +197,18 @@
                             break;
                         }
                     }
+                } else {
+                    // CraftBukkit - SPIGOT-2891: remove once chunk has been provided
+                    iterator.remove();
                 }
             }
+            } // Paper timing
         }
 
         if (!this.pendingSendToPlayers.isEmpty())
         {
             int i1 = 81;
+            try (Timing ignored = world.timings.doChunkMapPendingSendToPlayers.startTiming()) { // Paper
             Iterator<PlayerChunkMapEntry> iterator1 = this.pendingSendToPlayers.iterator();
 
             while (iterator1.hasNext())
@@ -207,16 +226,19 @@
                     }
                 }
             }
+            } // Paper timing
         }
 
         if (this.players.isEmpty())
         {
+            try (Timing ignored = world.timings.doChunkMapUnloadChunks.startTiming()) { // Paper
             WorldProvider worldprovider = this.world.provider;
 
-            if (!worldprovider.canRespawnHere())
+            if (!worldprovider.canRespawnHere() && !this.world.disableLevelSaving) // Paper - respect saving disabled setting
             {
                 this.world.getChunkProvider().queueUnloadAll();
             }
+            } // Paper timing
         }
     }
 
@@ -257,6 +279,16 @@
         return playerchunkmapentry;
     }
 
+    // CraftBukkit start - add method
+    public final boolean isChunkInUse(int x, int z) {
+        PlayerChunkMapEntry pi = getEntry(x, z);
+        if (pi != null) {
+            return (pi.players.size() > 0);
+        }
+        return false;
+    }
+    // CraftBukkit end
+
     public void markBlockForUpdate(BlockPos pos)
     {
         int i = pos.getX() >> 4;
@@ -276,14 +308,23 @@
         player.managedPosX = player.posX;
         player.managedPosZ = player.posZ;
 
+        // CraftBukkit start - Load nearby chunks first
+        List<ChunkPos> chunkList = new LinkedList<>();
+
         for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; ++k)
         {
             for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; ++l)
             {
-                this.getOrCreateEntry(k, l).addPlayer(player);
+                chunkList.add(new ChunkPos(k, l));
             }
         }
 
+        Collections.sort(chunkList, new ChunkCoordComparator(player));
+        for (ChunkPos pair : chunkList) {
+            this.getOrCreateEntry(pair.x, pair.z).addPlayer(player);
+        }
+        // CraftBukkit end
+
         this.players.add(player);
         this.markSortPending();
     }
@@ -341,6 +382,8 @@
             int j1 = i - k;
             int k1 = j - l;
 
+            List<ChunkPos> chunksToLoad = new LinkedList<>();
+
             if (j1 != 0 || k1 != 0)
             {
                 for (int l1 = i - i1; l1 <= i + i1; ++l1)
@@ -349,7 +392,8 @@
                     {
                         if (!this.overlaps(l1, i2, k, l, i1))
                         {
-                            this.getOrCreateEntry(l1, i2).addPlayer(player);
+                            // this.getOrCreateEntry(l1, i2).addPlayer(player);
+                            chunksToLoad.add(new ChunkPos(l1, i2)); // CraftBukkit
                         }
 
                         if (!this.overlaps(l1 - j1, i2 - k1, i, j, i1))
@@ -367,6 +411,12 @@
                 player.managedPosX = player.posX;
                 player.managedPosZ = player.posZ;
                 this.markSortPending();
+                // CraftBukkit start - send nearest chunks first
+                Collections.sort(chunksToLoad, new ChunkCoordComparator(player));
+                for (ChunkPos pair : chunksToLoad) {
+                    this.getOrCreateEntry(pair.x, pair.z).addPlayer(player);
+                }
+                // CraftBukkit end
             }
         }
     }
@@ -424,6 +474,7 @@
             this.markSortPending();
         }
     }
+    // Paper end
 
     private void markSortPending()
     {
@@ -456,11 +507,48 @@
         this.dirtyEntries.remove(entry);
         this.pendingSendToPlayers.remove(entry);
         this.entriesWithoutChunks.remove(entry);
-        Chunk chunk = entry.getChunk();
+    }
 
-        if (chunk != null)
-        {
-            this.getWorldServer().getChunkProvider().queueUnload(chunk);
+    // CraftBukkit start - Sorter to load nearby chunks first
+    private static class ChunkCoordComparator implements java.util.Comparator<ChunkPos> {
+        private int x;
+        private int z;
+
+        public ChunkCoordComparator (EntityPlayer entityplayer) {
+            x = (int) entityplayer.posX >> 4;
+            z = (int) entityplayer.posZ >> 4;
         }
+
+        public int compare(ChunkPos a, ChunkPos b) {
+            if (a.equals(b)) {
+                return 0;
+            }
+
+            // Subtract current position to set center point
+            int ax = a.x - this.x;
+            int az = a.z - this.z;
+            int bx = b.x - this.x;
+            int bz = b.z - this.z;
+
+            int result = ((ax - bx) * (ax + bx)) + ((az - bz) * (az + bz));
+            if (result != 0) {
+                return result;
+            }
+
+            if (ax < 0) {
+                if (bx < 0) {
+                    return bz - az;
+                } else {
+                    return -1;
+                }
+            } else {
+                if (bx < 0) {
+                    return 1;
+                } else {
+                    return az - bz;
+                }
+            }
+        }
     }
+    // CraftBukkit end
 }
