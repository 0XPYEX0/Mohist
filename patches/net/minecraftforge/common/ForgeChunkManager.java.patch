--- ../src-base/minecraft/net/minecraftforge/common/ForgeChunkManager.java
+++ ../src-work/minecraft/net/minecraftforge/common/ForgeChunkManager.java
@@ -22,7 +22,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -30,7 +29,6 @@
 import java.util.Objects;
 import java.util.Set;
 import java.util.UUID;
-import java.util.WeakHashMap;
 
 import javax.annotation.Nullable;
 
@@ -106,7 +104,6 @@
 
     private static Map<String, LoadingCallback> callbacks = Maps.newHashMap();
 
-    private static Map<World, ImmutableSetMultimap<ChunkPos,Ticket>> forcedChunks = Collections.synchronizedMap(new WeakHashMap<>());
     private static BiMap<UUID,Ticket> pendingEntities = HashBiMap.create();
 
     private static Map<World,Cache<Long, ChunkEntry>> dormantChunkCache = new MapMaker().weakKeys().makeMap();
@@ -467,7 +464,7 @@
         ArrayListMultimap<String, Ticket> newTickets = ArrayListMultimap.create();
         tickets.put(world, newTickets);
 
-        forcedChunks.put(world, ImmutableSetMultimap.of());
+        world.setForcedChunks(ImmutableSetMultimap.of());
 
         if (!(world instanceof WorldServer))
         {
@@ -615,14 +612,13 @@
 
     static void unloadWorld(World world)
     {
-        forcedChunks.remove(world);
-
         // World save fires before this event so the chunk loading info will be done
         if (!(world instanceof WorldServer))
         {
             return;
         }
 
+        world.setForcedChunks(ImmutableSetMultimap.of());
         if (dormantChunkCacheSize != 0) // only if in use
         {
             dormantChunkCache.remove(world);
@@ -817,8 +813,8 @@
         ticket.requestedChunks.add(chunk);
         MinecraftForge.EVENT_BUS.post(new ForceChunkEvent(ticket, chunk));
 
-        ImmutableSetMultimap<ChunkPos, Ticket> newMap = ImmutableSetMultimap.<ChunkPos,Ticket>builder().putAll(forcedChunks.get(ticket.world)).put(chunk, ticket).build();
-        forcedChunks.put(ticket.world, newMap);
+        ImmutableSetMultimap<ChunkPos, Ticket> newMap = ImmutableSetMultimap.<ChunkPos,Ticket>builder().putAll(ticket.world.getForcedChunks()).put(chunk, ticket).build();
+        ticket.world.setForcedChunks(newMap);
         if (ticket.maxDepth > 0 && ticket.requestedChunks.size() > ticket.maxDepth)
         {
             ChunkPos removed = ticket.requestedChunks.iterator().next();
@@ -857,10 +853,10 @@
         }
         ticket.requestedChunks.remove(chunk);
         MinecraftForge.EVENT_BUS.post(new UnforceChunkEvent(ticket, chunk));
-        LinkedHashMultimap<ChunkPos, Ticket> copy = LinkedHashMultimap.create(forcedChunks.get(ticket.world));
+        LinkedHashMultimap<ChunkPos, Ticket> copy = LinkedHashMultimap.create(ticket.world.getForcedChunks());
         copy.remove(chunk, ticket);
         ImmutableSetMultimap<ChunkPos, Ticket> newMap = ImmutableSetMultimap.copyOf(copy);
-        forcedChunks.put(ticket.world,newMap);
+        ticket.world.setForcedChunks(newMap);
     }
 
     static void loadConfiguration()
@@ -891,9 +887,7 @@
      */
     public static ImmutableSetMultimap<ChunkPos, Ticket> getPersistentChunksFor(World world)
     {
-        if (world.isRemote) return ImmutableSetMultimap.of();
-        ImmutableSetMultimap<ChunkPos, Ticket> persistentChunks = forcedChunks.get(world);
-        return persistentChunks != null ? persistentChunks : ImmutableSetMultimap.of();
+        return world.getForcedChunks();
     }
 
     static void saveWorld(World world)
