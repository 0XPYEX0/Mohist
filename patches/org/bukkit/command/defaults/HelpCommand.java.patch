--- ../src-base/minecraft/org/bukkit/command/defaults/HelpCommand.java
+++ ../src-work/minecraft/org/bukkit/command/defaults/HelpCommand.java
@@ -1,5 +1,6 @@
 package org.bukkit.command.defaults;
 
+import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -7,7 +8,6 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
-
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.apache.commons.lang.Validate;
@@ -21,21 +21,85 @@
 import org.bukkit.help.HelpTopicComparator;
 import org.bukkit.help.IndexHelpTopic;
 import org.bukkit.util.ChatPaginator;
+import red.mohist.util.i18n.Message;
 
-import com.google.common.collect.ImmutableList;
-
 public class HelpCommand extends BukkitCommand {
     public HelpCommand() {
         super("help");
         this.description = "Shows the help menu";
         this.usageMessage = "/help <pageNumber>\n/help <topic>\n/help <topic> <pageNumber>";
-        this.setAliases(Arrays.asList(new String[] { "?" }));
-        this.setPermission("bukkit.command.help");
+        this.setAliases(Arrays.asList("?"));
     }
 
+    /**
+     * Computes the Dameraur-Levenshtein Distance between two strings. Adapted
+     * from the algorithm at <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Wikipedia: Damerau–Levenshtein distance</a>
+     *
+     * @param s1 The first string being compared.
+     * @param s2 The second string being compared.
+     * @return The number of substitutions, deletions, insertions, and
+     * transpositions required to get from s1 to s2.
+     */
+    protected static int damerauLevenshteinDistance(String s1, String s2) {
+        if (s1 == null && s2 == null) {
+            return 0;
+        }
+        if (s1 != null && s2 == null) {
+            return s1.length();
+        }
+        if (s1 == null && s2 != null) {
+            return s2.length();
+        }
+
+        int s1Len = s1.length();
+        int s2Len = s2.length();
+        int[][] H = new int[s1Len + 2][s2Len + 2];
+
+        int INF = s1Len + s2Len;
+        H[0][0] = INF;
+        for (int i = 0; i <= s1Len; i++) {
+            H[i + 1][1] = i;
+            H[i + 1][0] = INF;
+        }
+        for (int j = 0; j <= s2Len; j++) {
+            H[1][j + 1] = j;
+            H[0][j + 1] = INF;
+        }
+
+        Map<Character, Integer> sd = new HashMap<Character, Integer>();
+        for (char Letter : (s1 + s2).toCharArray()) {
+            if (!sd.containsKey(Letter)) {
+                sd.put(Letter, 0);
+            }
+        }
+
+        for (int i = 1; i <= s1Len; i++) {
+            int DB = 0;
+            for (int j = 1; j <= s2Len; j++) {
+                int i1 = sd.get(s2.charAt(j - 1));
+                int j1 = DB;
+
+                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
+                    H[i + 1][j + 1] = H[i][j];
+                    DB = j;
+                } else {
+                    H[i + 1][j + 1] = Math.min(H[i][j], Math.min(H[i + 1][j], H[i][j + 1])) + 1;
+                }
+
+                H[i + 1][j + 1] = Math.min(H[i + 1][j + 1], H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));
+            }
+            sd.put(s1.charAt(i - 1), i);
+        }
+
+        return H[s1Len + 1][s2Len + 1];
+    }
+
     @Override
     public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
+        if (!sender.isOp()) {
+            sender.sendMessage(Message.getString("command.nopermission"));
+            return true;
+        }
 
         String command;
         int pageNumber;
@@ -117,7 +181,7 @@
         Validate.notNull(args, "Arguments cannot be null");
         Validate.notNull(alias, "Alias cannot be null");
 
-        if (args.length == 1) {
+        if (args.length == 1 && sender.isOp()) {
             List<String> matchedTopics = new ArrayList<String>();
             String searchString = args[0];
             for (HelpTopic topic : Bukkit.getServer().getHelpMap().getHelpTopics()) {
@@ -162,67 +226,4 @@
             return null;
         }
     }
-
-    /**
-     * Computes the Dameraur-Levenshtein Distance between two strings. Adapted
-     * from the algorithm at <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Wikipedia: Damerau–Levenshtein distance</a>
-     *
-     * @param s1 The first string being compared.
-     * @param s2 The second string being compared.
-     * @return The number of substitutions, deletions, insertions, and
-     * transpositions required to get from s1 to s2.
-     */
-    protected static int damerauLevenshteinDistance(String s1, String s2) {
-        if (s1 == null && s2 == null) {
-            return 0;
-        }
-        if (s1 != null && s2 == null) {
-            return s1.length();
-        }
-        if (s1 == null && s2 != null) {
-            return s2.length();
-        }
-
-        int s1Len = s1.length();
-        int s2Len = s2.length();
-        int[][] H = new int[s1Len + 2][s2Len + 2];
-
-        int INF = s1Len + s2Len;
-        H[0][0] = INF;
-        for (int i = 0; i <= s1Len; i++) {
-            H[i + 1][1] = i;
-            H[i + 1][0] = INF;
-        }
-        for (int j = 0; j <= s2Len; j++) {
-            H[1][j + 1] = j;
-            H[0][j + 1] = INF;
-        }
-
-        Map<Character, Integer> sd = new HashMap<Character, Integer>();
-        for (char Letter : (s1 + s2).toCharArray()) {
-            if (!sd.containsKey(Letter)) {
-                sd.put(Letter, 0);
-            }
-        }
-
-        for (int i = 1; i <= s1Len; i++) {
-            int DB = 0;
-            for (int j = 1; j <= s2Len; j++) {
-                int i1 = sd.get(s2.charAt(j - 1));
-                int j1 = DB;
-
-                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
-                    H[i + 1][j + 1] = H[i][j];
-                    DB = j;
-                } else {
-                    H[i + 1][j + 1] = Math.min(H[i][j], Math.min(H[i + 1][j], H[i][j + 1])) + 1;
-                }
-
-                H[i + 1][j + 1] = Math.min(H[i + 1][j + 1], H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));
-            }
-            sd.put(s1.charAt(i - 1), i);
-        }
-
-        return H[s1Len + 1][s2Len + 1];
-    }
 }
